# 作戦
・重みのリストをランダムに作成→→ニューラルネットの構造を作る
・順伝播する
・出力と教師信号と比較して誤差を求める関数と、重み＋hして順伝播した出力結果と、重みーhして順伝播した出力結果を使って、微小区間の変化量（傾き）を求める
・その傾き×学習率の値だけ、パラメータを調整する

ニューラルネットを作る関数は、引数にWとbの各パラメータをとる形のほうが良さそう
順伝播する関数の引数は、入力値だけでよいと思う
勾配を求める関数がとる引数は、（2乗和誤差、重み＋ｈの出力、重みーｈの出力とする）
各パラメータの微分値を、１つずつリストに入れていく。
パラメータのリストと、微分して求めた値のリストは同じ形なので、更新するところで引き算すれば、新たなパラメータのリストができる。
そのリストでニューラルネットを作り、
順伝播して・・

を繰り返す

# 失敗リスト
・関数「bibun_numerical_gradient」の引数の順番を逆にしていたため、勾配を降下せず上ってしまっていた  
・Pythonのリストとnp.arrayの違いがわかってなかった（listはどんな型でも並べられる。np.arrayは数値で、高速計算ができて、しかも要素全体に対する計算などを楽に書ける）  
・配列の形を整えず計算していたため変な結果が出た  
・パラメータを更新する部分がちゃんとできていなかった  
等